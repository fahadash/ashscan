namespace ExploitFinder
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Sockets;

    public abstract class IPAddressExploitChecker : IExploitChecker
    {
        public IPAddressExploitChecker()
            : base()
        {
        }

        public IEnumerable<ExploitType> Check(string data)
        {
            var ipAddresses = this.ResolveIPAddresses(data);
            var exploitTypes = this.TestIPAddresses(ipAddresses);

            return exploitTypes;
        }

        protected virtual IEnumerable<IPAddress> ResolveIPAddresses(string address)
        {
            var ipAddresses = new List<IPAddress>();

            var ipAddress = default(IPAddress);

            if (!IPAddress.TryParse(address, out ipAddress))
            {
                try
                {
                    var hostAddresses = Dns.GetHostAddresses(address);

                    ipAddresses.AddRange(hostAddresses);
                }
                catch
                {
                    // TODO : log exception -- Diabolic 15/03/2015
                }
            }
            else
            {
                ipAddresses.Add(ipAddress);
            }

            return ipAddresses;
        }

        protected virtual IEnumerable<ExploitType> TestIPAddresses(IEnumerable<IPAddress> ipAddresses)
        {
            var exploitTypes = new List<ExploitType>();

            foreach (var ipAddress in ipAddresses.Where(a => a.AddressFamily == AddressFamily.InterNetwork))
            {
                var addressBytes = ipAddress.GetAddressBytes();

                exploitTypes.AddRange(this.TestIPAddress(addressBytes));
            }

            return exploitTypes;
        }

        protected virtual IEnumerable<ExploitType> TestIPAddress(byte[] addressBytes)
        {
            var address = this.FormatAddress(addressBytes);

            try
            {
                var hostAddresses = Dns.GetHostAddresses(address);

                var exploitTypes = this.CheckHostAddresses(hostAddresses);

                return exploitTypes.ToArray();
            }
            catch
            {
                // TODO : log exception -- Diabolic 15/03/2015

                return Enumerable.Empty<ExploitType>();
            }
        }

        protected abstract string FormatAddress(byte[] addressBytes);

        protected abstract IEnumerable<ExploitType> CheckHostAddresses(IPAddress[] hostAddresses);
    }
}