using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ExploitChecker
{
    using Contracts;

    namespace Services
    {
        public class AbusiveNickExploitChecker : ListExploitChecker<IAbusiveWordProvider>
        {
            private Func<IEnumerable<string>> nicksFunc;

            public AbusiveNickExploitChecker(IAbusiveWordProvider abusiveWordProvider, Func<IEnumerable<string>> nicksFunc)
                : base(abusiveWordProvider)
            {
                this.nicksFunc = nicksFunc;
            }

            protected virtual Func<IEnumerable<string>> NicksFunc
            {
                get
                {
                    return this.nicksFunc;
                }
            }

            public override IEnumerable<ExploitType> Check(Func<string> data)
            {
                var nick = data();
                var nicks = Enumerable.Empty<string>();

                if (NicksFunc != null)
                {
                    nicks = NicksFunc();
                }

                // NOTE : explain the logic here -- Diabolic 15/03/2015
                var combinedNicks = nicks
                    .Concat(ListProvider.GetAll())
                    .Select(RemoveSpecialChars)
                    .Select(n => n.ToLower())
                    .Distinct()
                    .Where(n => !string.IsNullOrWhiteSpace(n));

                nick = RemoveSpecialChars(nick).ToLower();

                if (combinedNicks.Any(nick.Contains))
                {
                    return new[] { ExploitType.Nick_Abuser };
                }

                return Enumerable.Empty<ExploitType>();
            }

            private string RemoveSpecialChars(string @string)
            {
                return @string.Where(char.IsLetterOrDigit).Aggregate(new StringBuilder(), (s, c) => s.Append(c)).ToString();
            }
        }
    }
}