namespace ExploitFinder
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Sockets;

    using ExploitChecker;

    public class DnsExploitFinder : IHostExploitFinder
    {
        public string ProviderName { get; set; }
        public string HostSuffix { get; set; }

        public Dictionary<int, Exploit> ExploitDictionary { get; set; }

        public IEnumerable<Exploit> Run(string data)
        {
            var ipAddresses = this.ResolveIPAddresses(data);

           var tests = ipAddresses.Where(a => a.AddressFamily == AddressFamily.InterNetwork).Select(
                a =>
                    {
                        var addressBytes = a.GetAddressBytes();
                        return string.Format(
                            "{0}.{1}.{2}.{3}." + this.HostSuffix,
                            Convert.ToInt32(addressBytes[3]),
                            Convert.ToInt32(addressBytes[2]),
                            Convert.ToInt32(addressBytes[1]),
                            Convert.ToInt32(addressBytes[0]));
                    });
            var list = new List<Exploit>();
            foreach (var test in tests)
            {
                try
                {
                    var hostAddresses = Dns.GetHostAddresses(test);

                    var results =
                        hostAddresses.Select(h => Convert.ToInt32(h.GetAddressBytes()[3]))
                            .Select(
                                h =>
                                this.ExploitDictionary.ContainsKey(h)
                                    ? this.ExploitDictionary[h]
                                    : new Exploit(ExploitType.Other, " Unknown " + this.ProviderName));

                    list.AddRange(results);
                }
                catch
                {
                    // TODO : log exception -- Diabolic 15/03/2015

                    return Enumerable.Empty<Exploit>();
                }
            }

            return list;
        }

        protected virtual IEnumerable<IPAddress> ResolveIPAddresses(string address)
        {
            var ipAddresses = new List<IPAddress>();

            var ipAddress = default(IPAddress);

            if (!IPAddress.TryParse(address, out ipAddress))
            {
                try
                {
                    var hostAddresses = Dns.GetHostAddresses(address);

                    ipAddresses.AddRange(hostAddresses);
                }
                catch
                {
                    // TODO : log exception -- Diabolic 15/03/2015
                }
            }
            else
            {
                ipAddresses.Add(ipAddress);
            }

            return ipAddresses;
        }
    }
}
