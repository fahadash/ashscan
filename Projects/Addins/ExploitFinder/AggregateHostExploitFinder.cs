namespace ExploitFinder
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.InteropServices;

    using ExploitChecker;

    using Extensibility;

    using Mono.Addins;

    public class AggregateHostExploitFinder
    {
        private readonly IEnumerable<IExploitFinder> exploitFinders;
        private readonly ExploitFinderManager manager = new ExploitFinderManager();
        private readonly Func<string, IEnumerable<string>> voicedNicksFunc = null;

        internal static string NickBanlistFile { get; set; }
        internal static string HostBanlistFile { get; set; }

        internal static BlackListedHostExploitFinder BlackListedHostExploitFinder { get; set; }
        internal static AbusiveNickExploitFinder AbusiveNickExploitFinder { get; set; }

        public AggregateHostExploitFinder(IStorageProvider storage, Func<string, IEnumerable<string>> voicedNicksFunc)
        {

            var length = storage.Retrieve(Constants.Config_LengthTooLong);
            int maxNickLength = 20;
            if (!int.TryParse(length, out maxNickLength))
            {
                maxNickLength = 20;
            }
            this.voicedNicksFunc = voicedNicksFunc;
            AbusiveNickExploitFinder = new AbusiveNickExploitFinder(storage, maxNickLength);
            BlackListedHostExploitFinder = new BlackListedHostExploitFinder(storage);

            this.exploitFinders = this.manager.GetHostExploitFinders()
                .Concat(new IExploitFinder[] {  BlackListedHostExploitFinder})
                .ToArray();
        }

        public IEnumerable<Exploit> Run(IUserInfo user, string channel)
        {
            var voiced = new Func<IEnumerable<string>>(() => voicedNicksFunc(channel));
            var nickExploits = AbusiveNickExploitFinder.Run(user, voiced);
            return this.exploitFinders.SelectMany(e => e.Run(user)).Concat(nickExploits).ToArray();
        }
    }
}
