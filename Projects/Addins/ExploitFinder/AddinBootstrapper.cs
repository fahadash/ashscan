using Extensibility;
using Extensibility.Attributes;
using Extensibility.Contracts;
using Mono.Addins;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reactive.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ExploitFinder
{
    [Extension]
    public class AddinBootstrapper : IAddinBootstrapper
    {
        List<string> ignoredChannels = new List<string>();
        AggregateHostExploitFinder exploitFinders = null;
        Dictionary<int, IEnumerable<Exploit>> toleranceSheet = null;
        internal static int tolerance = 5;

        [Dependency(typeof(IIrcController))]
        public IIrcController controller { get; set; }


        [Dependency(typeof(IFileSystemInfo))]
        public IFileSystemInfo fileSystem { get; set; }


        [Dependency(typeof(IStorageProvider))]
        public IStorageProvider storage { get; set; }

        public AddinBootstrapper()
        {
        }

        public string ImportBannedHost(string fileName)
        {
            var file = Path.Combine(fileSystem.DataPath, fileName);

            return AggregateHostExploitFinder.BlackListedHostExploitFinder.Import(file);
        }
        
        public string ImportBannedNickWords(string fileName)
        {
            var file = Path.Combine(fileSystem.DataPath, fileName);

            return AggregateHostExploitFinder.AbusiveNickExploitFinder.Import(file);
        }

        public string ExportBannedHost(string fileName)
        {
            var file = Path.Combine(fileSystem.DataPath, fileName);

            return AggregateHostExploitFinder.BlackListedHostExploitFinder.Export(file);
        }

        public string ExportBannedNickWords(string fileName)
        {
            var file = Path.Combine(fileSystem.DataPath, fileName);

            return AggregateHostExploitFinder.AbusiveNickExploitFinder.Export(file);
        }

        public bool Run()
        {
            ExploitCommandsHandler.bootStrapper = this;
            storage.Open(Constants.Tablename);
            var stringTolerance = storage.Retrieve(Constants.Config_Tolerance);

            if (!int.TryParse(stringTolerance, out tolerance))
            {
                tolerance = 5;
            }

            this.exploitFinders = new AggregateHostExploitFinder(
                        storage,
                        channel => controller.GetChannelUsers(channel)
                        .Where(u => u.Modes.Contains(UserChannelMode.Voice))
                        .Select(u => u.User.Nick));
            toleranceSheet = GetUntoleratedExploitTypes();
            controller
                    .Joins
                    .Subscribe(j => this.HandleJoin(j.Item1, j.Item2));

            return true;
        }

        void HandleJoin(string channel, IUserInfo user)
        {

            if (!this.ignoredChannels.Any(c=> c.Equals(channel, StringComparison.OrdinalIgnoreCase)))
            {
                // Use pLinq here to run the exploit finders in parallel
                // And write the logic to wait for the first intolerated exploit and
                // trigger the kick
                var exploitTypes = this.exploitFinders.Run(user, channel).ToArray();


                var exploitsString = string.Empty;

                exploitsString = string.Join(",", exploitTypes.Select(t => t.Description));

                if (exploitTypes.Any())
                {
                    var untoleratedExploitTypes = this.toleranceSheet[tolerance];

                    if (exploitTypes.Select(t => t.Type).Any(untoleratedExploitTypes.Select(u => u.Type).Contains))
                    {

                        controller.Say(controller.ReportingChannel, string.Format(
                                "Positive Match: in {0}, Nick: {1}, Host {2}, Exploits: {3}",
                                channel,
                                user.Nick,
                                user.Host,
                                exploitTypes.Any() ? exploitsString : "None"));

                        if (controller.AmIOp(channel))
                        {
                            controller.Ban(channel, string.Format("*!*@{1}", user.Host));
                            controller.Kick(channel, user.Nick, "Using proxies, exploits, banned hosts are not allowed");
                        }
                    }
                    else
                    {
                            controller.Say(controller.ReportingChannel, string.Format(
                                "Joins {0}, Nick: {1}, Host {2}, Exploits: {3}",
                                channel,
                                user.Nick,
                                user.Host,
                                exploitTypes.Any() ? exploitsString : "None"));
                    }
                }
            }
        }


        private Dictionary<int, IEnumerable<Exploit>> GetUntoleratedExploitTypes()
        {
            return new Dictionary<int, IEnumerable<Exploit>>()
                                      {
                                          {10, new [] {new Exploit(ExploitType.Banlist_Match)}},
                                          {9, new [] {new Exploit(ExploitType.Banlist_Match)}},
                                          {8, new [] {new Exploit(ExploitType.Banlist_Match)}},
                                          {7, new [] {new Exploit(ExploitType.Banlist_Match), new Exploit(ExploitType.Nick_Abuser)}},
                                          {6, new [] {new Exploit(ExploitType.Banlist_Match), new Exploit(ExploitType.Nick_Abuser)}},
                                          {5, new [] {new Exploit(ExploitType.Banlist_Match), 
                                              new Exploit(ExploitType.Nick_Abuser)}},
                                          {4, new [] {new Exploit(ExploitType.Banlist_Match), 
                                              new Exploit(ExploitType.Nick_Abuser),
                                          new Exploit(ExploitType.OpenWingateProxy),
                                          new Exploit(ExploitType.SocksProxy),
                                          new Exploit(ExploitType.ProxyChain),
                                          }},
                                          {3, new [] {new Exploit(ExploitType.Banlist_Match), 
                                              new Exploit(ExploitType.Nick_Abuser),
                                          new Exploit(ExploitType.OpenProxy),
                                          new Exploit(ExploitType.OpenWingateProxy),
                                          new Exploit(ExploitType.HTTPProxy),
                                          new Exploit(ExploitType.SocksProxy),
                                          new Exploit(ExploitType.IRCDrone),
                                          new Exploit(ExploitType.Bottler),
                                          new Exploit(ExploitType.ProxyChain),
                                          new Exploit(ExploitType.AutomaticallyDeterminedBotnet),
                                          new Exploit(ExploitType.DDOSDrone),
                                          new Exploit(ExploitType.UnknownSpambotOrDrone),
                                          }},
                                          {2, new [] {new Exploit(ExploitType.Banlist_Match), 
                                              new Exploit(ExploitType.Nick_Abuser),
                                          new Exploit(ExploitType.OpenProxy),
                                          new Exploit(ExploitType.OpenWingateProxy),
                                          new Exploit(ExploitType.HTTPProxy),
                                          new Exploit(ExploitType.SocksProxy),
                                          new Exploit(ExploitType.IRCDrone),
                                          new Exploit(ExploitType.Bottler),
                                          new Exploit(ExploitType.ProxyChain),
                                          new Exploit(ExploitType.AutomaticallyDeterminedBotnet),
                                          new Exploit(ExploitType.DDOSDrone),
                                          new Exploit(ExploitType.UnknownSpambotOrDrone),
                                          }},{1, new [] {new Exploit(ExploitType.Banlist_Match), 
                                              new Exploit(ExploitType.Nick_Abuser),
                                          new Exploit(ExploitType.OpenProxy),
                                          new Exploit(ExploitType.OpenWingateProxy),
                                          new Exploit(ExploitType.HTTPProxy),
                                          new Exploit(ExploitType.SocksProxy),
                                          new Exploit(ExploitType.IRCDrone),
                                          new Exploit(ExploitType.Bottler),
                                          new Exploit(ExploitType.ProxyChain),
                                          new Exploit(ExploitType.AutomaticallyDeterminedBotnet),
                                          new Exploit(ExploitType.DDOSDrone),
                                          new Exploit(ExploitType.UnknownSpambotOrDrone),
                                          }},
                                      };
        }
    }
}
