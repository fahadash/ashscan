using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Reactive.Concurrency;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Threading;
using System.Threading.Tasks;
using ChatSharp;
using ChatSharp.Events;

namespace IrcExploitChecker.App
{
    using ExploitFinder;

    using Extensibility;

    using Mono.Addins;

    using Properties;

    public class Service
    {
        private bool beVerbose;

        private IEnumerable<string> ignoredChannels;

        private IEnumerable<string> watchedChannels;

        private IEnumerable<string> botOperators;

        internal static IrcClient ircClient;

        private CancellationTokenSource cancellationTokenSource;

        internal static ConcurrentQueue<string> rawMessageQueue;

        private IConnectableObservable<string> raw;

        private IDisposable rawHolder;
        private AggregateHostExploitFinder exploitFinders;
        
        public Service()
            : base()
        {
            var blackListedHostsPath = File.Exists(Settings.Default.BlackListedHostsPath)
                                      ? Settings.Default.BlackListedHostsPath
                                      : ConfigurationManager.AppSettings["BannedHostsPath"];
            var abusiveWordsPath = File.Exists(Settings.Default.AbusiveWordsPath)
                                      ? Settings.Default.AbusiveWordsPath
                                      : ConfigurationManager.AppSettings["BannedWordsPath"];

            this.beVerbose = Settings.Default.BeVerbose;
            this.ignoredChannels = new[]
            {
                Settings.Default.ReportingChannel
            };
            this.watchedChannels = Settings.Default.WatchedChannels.Split(',').Where(c => c.StartsWith("#"));
            this.botOperators = Settings.Default.BotOperators.Split(',').Select(o => o.Trim());

            ircClient = new IrcClient(Settings.Default.Network, new IrcUser(Settings.Default.Nick, Settings.Default.Username));

            // NOTE : do these objects have to be recreated between reconnects? -- Diabolic 15/03/2015
            this.cancellationTokenSource = new CancellationTokenSource();
            rawMessageQueue = new ConcurrentQueue<string>();
            this.raw = Observable.Create<string>
            (
                (o, t) => Task.Factory.StartNew
                (
                    () =>
                    {
                        while (!t.IsCancellationRequested)
                        {
                            Thread.Sleep(TimeSpan.FromSeconds(1.0));

                            var message = string.Empty;

                            if (rawMessageQueue.TryDequeue(out message) && !string.IsNullOrWhiteSpace(message))
                            {
                                o.OnNext(message);
                            }
                        }
                    },
                    t)).Publish();
            this.raw.ObserveOn(Scheduler.Default).Subscribe((message) => ircClient.SendRawMessage(message));
            this.rawHolder = this.raw.Connect();
            this.exploitFinders = new AggregateHostExploitFinder(
                abusiveWordsPath,
                () =>
                ircClient.Channels.SelectMany(
                    c => c.UsersByMode.ContainsKey('v') ? c.UsersByMode['v'] : Enumerable.Empty<IrcUser>())
                    .Select(a => a.Nick)
                    .ToList(),
                blackListedHostsPath,
                Settings.Default.LongNickLength);      

            ircClient.ConnectionComplete += HandleClientConnectionCompleteEvent;
            ircClient.RawMessageRecieved += HandleRawMessageReceived;
            ircClient.UserMessageRecieved += HandleUserMessageReceived;
            ircClient.UserJoinedChannel += HandleUserJoinedChannel;
        }

        public void Start()
        {
            ircClient.ConnectAsync();
        }

        public void Stop()
        {
            rawHolder.Dispose();
            ircClient.Quit();
        }

        private void HandleClientConnectionCompleteEvent(object sender, EventArgs e)
        {
            var client = sender as IrcClient;

            if (client != null)
            {
                client.JoinChannel(Settings.Default.ReportingChannel);

                client.SendRawMessage(":MODE {0} +iRCB-ws", Settings.Default.Nick);
                client.SendRawMessage("NickServ IDENTIFY " + Settings.Default.NickservPassword);

                // TODO : remove the Thread.Sleep; replace with asynchronous code in an appropriate event -- Diabolic 15/03/2015
                Thread.Sleep(100);

                this.watchedChannels.ToList().ForEach(client.JoinChannel);
            }
        }

        private void HandleRawMessageReceived(object sender, RawMessageEventArgs e)
        {
            Console.WriteLine(e.Message);
        }

        private void HandleUserMessageReceived(object sender, PrivateMessageEventArgs e)
        {
            var client = sender as IrcClient;

            if (client != null)
            {
                try
                {
                    if (e.PrivateMessage != null)
                    {
                        if (this.botOperators.Any(x => string.Equals(x, e.PrivateMessage.User.Nick, StringComparison.OrdinalIgnoreCase)))
                        {
                            var split = e.PrivateMessage.Message.Split(' ');

                            var command = ExtensionManager.GetCommandHandler(split[0]);

                            if (command != null)
                            {
                                command.Handle(new UserInfo(e.PrivateMessage.User),  split);
                            }

                        }
                    }
                }
                catch
                {
                    // TODO : log exception -- Diabolic 15/03/2015
                }
            }
        }

        private void HandleUserJoinedChannel(object sender, ChannelUserEventArgs e)
        {
            var client = sender as IrcClient;

            if (!this.ignoredChannels.Contains(e.Channel.Name.ToLower()))
            {
                var exploitTypes = this.exploitFinders.Run(new UserInfo(e.User)).ToArray();


                var exploitsString = string.Empty;

                exploitsString = string.Join(",", exploitTypes.Select(t => t.Description));

                if (this.beVerbose || exploitTypes.Any())
                {
                    var untoleratedExploitTypes = GetUntoleratedExploitTypes();

                    if (exploitTypes.Select(t => t.Type).Any(untoleratedExploitTypes.Contains))
                    {
                        rawMessageQueue.Enqueue
                        (
                            string.Format
                            (
                                "PRIVMSG {0} :KICK Trigger: in {1}, Nick: {2}, Host {3}, Exploits: {4}",
                                Settings.Default.ReportingChannel,
                                e.Channel.Name,
                                e.User.Nick,
                                e.User.Hostname,
                                exploitTypes.Any() ? exploitsString : "None"));

                        if (e.Channel != null && e.Channel.UsersByMode.ContainsKey('o') && e.Channel.UsersByMode['o'].Any(x => x.Nick == client.User.Nick))
                        {
                            client.SendRawMessage("MODE {0} +b *!*@{1}", e.Channel.Name, e.User.Hostname);

                            e.Channel.Kick(e.User.Nick, Settings.Default.KickReason);
                        }
                    }
                    else
                    {
                        rawMessageQueue.Enqueue
                        (
                            string.Format
                            (
                                "PRIVMSG {0} :Joins {1}, Nick: {2}, Host {3}, Exploits: {4}",
                                Settings.Default.ReportingChannel,
                                e.Channel.Name,
                                e.User.Nick,
                                e.User.Hostname,
                                exploitTypes.Any() ? exploitsString : "None"));
                    }
                }
            }
        }

        private IEnumerable<ExploitType> GetUntoleratedExploitTypes()
        {
            var exploitTypes = new List<ExploitType>();

            switch (Settings.Default.ToleranceLevel)
            {
                case 10:
                    exploitTypes.Add(ExploitType.Banlist_Match);
                    break;

                case 7:
                    exploitTypes.Add(ExploitType.Nick_Abuser);
                    break;

                case 5:
                    exploitTypes.Add(ExploitType.OpenProxy);
                    exploitTypes.Add(ExploitType.OpenWingateProxy);
                    exploitTypes.Add(ExploitType.HTTPProxy);
                    exploitTypes.Add(ExploitType.SocksProxy);
                    exploitTypes.Add(ExploitType.ProxyChain);
                    break;

                case 3:
                    exploitTypes.Add(ExploitType.IRCDrone);
                    exploitTypes.Add(ExploitType.Bottler);
                    exploitTypes.Add(ExploitType.AutomaticallyDeterminedBotnet);
                    //exploitTypes.Add(ExploitType.Drones_Flooding);
                    exploitTypes.Add(ExploitType.DDOSDrone);
                    exploitTypes.Add(ExploitType.UnknownSpambotOrDrone);
                    break;
            }

            return exploitTypes.Distinct();
        }
    }
}