using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reactive.Subjects;
using System.Text;
using System.Threading.Tasks;

namespace IrcExploitChecker
{
    using System.Reactive.Concurrency;
    using System.Reactive.Linq;
    using System.Threading;
    using Contracts;

    namespace Services
    {
        public class MessageQueueContainer : IMessageQueueContainer
        {
            private ConcurrentQueue<string> messageQueue;

            private IConnectableObservable<string> observable;

            private IDisposable disposable;

            public MessageQueueContainer()
                : base()
            {
                this.messageQueue = new ConcurrentQueue<string>();
                this.observable = Observable.Create<string>
                (
                    (o, t) => Task.Factory.StartNew
                    (
                        () =>
                        {
                            while (!t.IsCancellationRequested)
                            {
                                Thread.Sleep(TimeSpan.FromSeconds(1.0));

                                var message = string.Empty;

                                if (this.messageQueue.TryDequeue(out message) && !string.IsNullOrWhiteSpace(message))
                                {
                                    o.OnNext(message);
                                }
                            }
                        },
                        t
                    )
                ).Publish();
                this.observable.ObserveOn(Scheduler.Default).Subscribe((message) => RaiseMessageDequeuedEvent(message));
                this.disposable = this.observable.Connect();
            }

            public void Dispose()
            {
                this.disposable.Dispose();
                this.disposable = null;

                this.observable = null;

                var message = string.Empty;

                // TODO : should we be doing this on dispose? -- Diabolic 16/03/2015
                while (this.messageQueue.TryDequeue(out message))
                {
                    RaiseMessageDiscardedEvent(message);
                }
            }

            public void Enqueue(string message)
            {
            }

            public void Enqueue(string format, params object[] args)
            {
                Enqueue(string.Format(format, args));
            }

            public event MessageQueueEventHandler MessageDiscarded;

            private void RaiseMessageDiscardedEvent(string message)
            {
                var h = MessageDiscarded;
                var e = new MessageQueueEventArgs(message);

                if (h != null)
                {
                    h.Invoke(this, e);
                }
            }

            public event MessageQueueEventHandler MessageDequeued;

            private void RaiseMessageDequeuedEvent(string message)
            {
                var h = MessageDequeued;
                var e = new MessageQueueEventArgs(message);

                if (h != null)
                {
                    h.Invoke(this, e);
                }
            }
        }
    }
}