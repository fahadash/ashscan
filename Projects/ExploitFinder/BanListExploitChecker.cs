namespace ExploitFinder
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;

    using ExploitChecker;

    using Extensibility;

    internal abstract class BanListExploitFinder : IBanListExploitFinder
    {
        private List<string> banList;

        private IStorageProvider banListStorage;
        private string storageKey;

        internal BanListExploitFinder(IStorageProvider banList, string storageKey)
            : base()
        {
            if (banList == null)
            {
                throw new ArgumentNullException("Banlist Provider cannot be null or empty");
            }

            this.banList = new List<string>();
            banListStorage = banList;
            this.storageKey = storageKey;
            this.ReadBanlist();

        }


        protected virtual List<string> BanList
        {
            get
            { 
                return this.banList;
            }
        }

        private void ReadBanlist()
        {
            var list = banListStorage.Retrieve(storageKey) ?? string.Empty;
            this.banList =
                list
                .Split(new string[] { Environment.NewLine } , StringSplitOptions.RemoveEmptyEntries)
                .Select(s => s.Trim())
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .Distinct()
                .ToList();
        }

        private void WriteBanlist()
        {
            string content = string.Join(Environment.NewLine, banList);

            banListStorage.Remove(storageKey);
            banListStorage.Store(storageKey, content);
        }
        private IEnumerable<string> ReadFile(string filePath)
        {
            using (var reader = new StreamReader(filePath))
            {
                var line = string.Empty;
                var templist = new List<string>();

                while ((line = reader.ReadLine()) != null)
                {
                    yield return line.Trim();
                }
            }
        }

        public abstract IEnumerable<Exploit> Run(IUserInfo user);

        public virtual bool Contains(string entry)
        {
            return this.BanList.Contains(entry);
        }

        public virtual void Add(string entry)
        {
            if (!this.Contains(entry))
            {
                this.BanList.Add(entry);
                this.WriteBanlist();
            }
        }

        public virtual void Reload()
        {
            this.ReadBanlist();
        }

        public virtual void Remove(string entry)
        {
            if (this.Contains(entry))
            {
                this.BanList.Remove(entry);
                this.WriteBanlist();
            }
        }

        public virtual IEnumerable<string> GetAll()
        {
            return this.BanList.ToArray();
        }

        public virtual void SetAll(IEnumerable<string> banList)
        {
            this.BanList.Clear();
            this.BanList.AddRange(banList);
            this.WriteBanlist();
        }


        public string Import(string fileName)
        {
            if (!File.Exists(fileName))
            {
                return "File not found: " + Path.GetFileName(fileName);
            }

            var entries = ReadFile(fileName);

            SetAll(this.banList.Concat(
            entries.Where(e => !this.banList.Contains(e))).ToArray());

            return "Import successful";
        }


        public string Export(string fileName)
        {
            if (File.Exists(fileName))
            {
                File.Delete(fileName);
            }

            string content = string.Join(Environment.NewLine, banList);

            using (var writer = new StreamWriter(fileName))
            {
                writer.Write(content);
                writer.Close();
            }

            return "Export successful";
        }
    }
}