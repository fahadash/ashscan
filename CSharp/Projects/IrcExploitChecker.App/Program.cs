using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Reactive.Concurrency;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using ChatSharp;
using ChatSharp.Events;
using ExploitChecker;

namespace IrcExploitChecker.App
{
    using Properties;

    class Program
    {
        private bool beVerbose;

        private IEnumerable<string> ignoredChannels;

        private IEnumerable<string> watchedChannels;

        private IEnumerable<string> botOperators;

        private IrcClient ircClient;

        private CancellationTokenSource cancellationTokenSource;

        private ConcurrentQueue<string> rawMessageQueue;

        private IObservable<string> raw;

        private BarracudaExploitChecker barracudaExploitChecker;

        private DroneBlExploitChecker droneBlExploitChecker;

        private EfNetRblExploitChecker efNetRblExploitChecker;

        private TorSectoorExploitChecker torSectoorExploitChecker;

        private BlackListedHostExploitChecker blackListedHostExploitChecker;

        private LongNickExploitChecker longNickExploitChecker;

        private AbusiveNickExploitChecker abusiveNickExploitChecker;

        private AggregateExploitChecker hostnameExploitChecker;

        private AggregateExploitChecker nickExploitChecker;

        public Program(string blackListedHostsPath, string abusiveWordsPath)
            : base()
        {
            this.beVerbose = Settings.Default.BeVerbose;
            this.ignoredChannels = new[]
            {
                Settings.Default.ReportingChannel
            };
            this.watchedChannels = Settings.Default.WatchedChannels.Split(',').Where(c => c.StartsWith("#"));
            this.botOperators = Settings.Default.BotOperators.Split(',').Select(o => o.Trim());

            this.ircClient = new IrcClient(Settings.Default.Network, new IrcUser(Settings.Default.Nick, Settings.Default.Username));

            this.cancellationTokenSource = new CancellationTokenSource();
            this.rawMessageQueue = new ConcurrentQueue<string>();
            this.raw = Observable.Create<string>
            (
                (o, t) => Task.Factory.StartNew
                (
                    () =>
                    {
                        while (!t.IsCancellationRequested)
                        {
                            Thread.Sleep(TimeSpan.FromSeconds(1.0));

                            var message = string.Empty;

                            if (this.rawMessageQueue.TryDequeue(out message) && !string.IsNullOrWhiteSpace(message))
                            {
                                o.OnNext(message);
                            }
                        }
                    },
                    t
                )
            ).Publish();

            this.raw.ObserveOn(Scheduler.Default).Subscribe((message) => this.ircClient.SendRawMessage(message));
            // TODO : verify the following line -- Diabolic 15/03/2015
            // this.raw.Collect();

            this.barracudaExploitChecker = new BarracudaExploitChecker();
            this.droneBlExploitChecker = new DroneBlExploitChecker();
            this.efNetRblExploitChecker = new EfNetRblExploitChecker();
            this.torSectoorExploitChecker = new TorSectoorExploitChecker();
            this.blackListedHostExploitChecker = new BlackListedHostExploitChecker(blackListedHostsPath);
            this.longNickExploitChecker = new LongNickExploitChecker(Settings.Default.LongNickLength);
            this.abusiveNickExploitChecker = new AbusiveNickExploitChecker
            (
                abusiveWordsPath,
                () =>
                    this.ircClient.Channels.SelectMany
                    (
                        c => c.UsersByMode.ContainsKey('v')
                            ? c.UsersByMode['v']
                            : Enumerable.Empty<IrcUser>()
                    )
                    .Select(a => a.Nick)
                    .ToList()
            );

            this.hostnameExploitChecker = new AggregateExploitChecker
            (
                this.barracudaExploitChecker,
                this.droneBlExploitChecker,
                this.efNetRblExploitChecker,
                this.torSectoorExploitChecker,
                this.blackListedHostExploitChecker
            );
            this.nickExploitChecker = new AggregateExploitChecker
            (
                this.longNickExploitChecker,
                this.abusiveNickExploitChecker
            );

            this.ircClient.ConnectionComplete += HandleClientConnectionCompleteEvent;
            this.ircClient.RawMessageRecieved += HandleRawMessageReceived;
            this.ircClient.UserMessageRecieved += HandleUserMessageReceived;
            this.ircClient.UserJoinedChannel += HandleUserJoinedChannel;

            this.ircClient.ConnectAsync();
        }

        static void Main(string[] args)
        {
            var bannedHostsPath = File.Exists(Settings.Default.BlackListedHostsPath)
                                      ? Settings.Default.BlackListedHostsPath
                                      : ConfigurationManager.AppSettings["BannedHostsPath"];
            var bannedWordsPath = File.Exists(Settings.Default.AbusiveWordsPath)
                                      ? Settings.Default.AbusiveWordsPath
                                      : ConfigurationManager.AppSettings["BannedWordsPath"];

            while (true)
            {
                Thread.Sleep(2000);
            }
        }

        private void HandleClientConnectionCompleteEvent(object sender, EventArgs e)
        {
            var client = sender as IrcClient;

            if (client != null)
            {
                client.JoinChannel(Settings.Default.ReportingChannel);

                client.SendRawMessage(":MODE {0} +iRCB-ws", Settings.Default.Nick);
                client.SendRawMessage("NickServ IDENTIFY " + Settings.Default.NickservPassword);

                // TODO : remove the Thread.Sleep; replace with asynchronous code in an appropriate event -- Diabolic 15/03/2015
                Thread.Sleep(100);

                this.watchedChannels.ToList().ForEach(client.JoinChannel);
            }
        }

        private void HandleRawMessageReceived(object sender, RawMessageEventArgs e)
        {
            Console.WriteLine(e.Message);
        }

        private void HandleUserMessageReceived(object sender, PrivateMessageEventArgs e)
        {
            var client = sender as IrcClient;

            if (client != null)
            {
                try
                {
                    if (e.PrivateMessage != null)
                    {
                        if (this.botOperators.Any(x => x.ToLower().Equals(e.PrivateMessage.User.Nick.ToLower())))
                        {
                            var split = e.PrivateMessage.Message.Split(' ');

                            switch (split[0].ToLower())
                            {
                                case "join":
                                    #region handle join
                                    client.JoinChannel(split[1]);
                                    #endregion
                                    break;

                                case "part":
                                    #region handle part
                                    client.PartChannel(split[1]);
                                    #endregion
                                    break;

                                case "check":
                                    #region handle check
                                    {
                                        var exploitTypes = this.hostnameExploitChecker.Check(() => split[1]);
                                        var exploitString = exploitTypes.Aggregate(new StringBuilder(), (sb, et) => sb.AppendFormat("{0},", et.ToString())).ToString();

                                        client.Channels[Settings.Default.ReportingChannel].SendMessage
                                        (
                                            string.Format
                                            (
                                                "Manual check requested by {0}, Host {1}, Exploits: {2}",
                                                e.PrivateMessage.User.Nick,
                                                split[1],
                                                exploitString
                                            )
                                        );

                                        this.rawMessageQueue.Enqueue("PRIVMSG " + e.PrivateMessage.User.Nick + " :" + exploitString);
                                    }
                                    #endregion
                                    break;

                                case "tolerance":
                                    #region handle tolerance
                                    {
                                        if (split.Length > 1)
                                        {
                                            var newlevel = 0;

                                            if (!int.TryParse(split[1], out newlevel) || newlevel < 0 || newlevel > 10)
                                            {
                                                this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Invalid level. Choose between 0-10", e.PrivateMessage.User.Nick));
                                            }
                                            else
                                            {
                                                Settings.Default.ToleranceLevel = newlevel;
                                                Settings.Default.Save();

                                                this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Current Tolerance level is now set to: {1}", e.PrivateMessage.User.Nick, Settings.Default.ToleranceLevel));
                                            }
                                        }
                                        else
                                        {
                                            this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Current Tolerance level is: {1}", e.PrivateMessage.User.Nick, Settings.Default.ToleranceLevel));
                                        }
                                    }
                                    #endregion
                                    break;

                                case "blacklist":
                                    #region handle blacklist
                                    if (split.Length > 2)
                                    {
                                        switch (split[1].ToLower())
                                        {
                                            case "add":
                                                if (this.blackListedHostExploitChecker.Contains(split[2]))
                                                {
                                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Host already exists.", e.PrivateMessage.User.Nick));
                                                }
                                                else
                                                {
                                                    this.blackListedHostExploitChecker.Add(split[2]);

                                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Host successfully added.", e.PrivateMessage.User.Nick));
                                                }
                                                break;

                                            case "remove":
                                                if (!this.blackListedHostExploitChecker.Contains(split[2]))
                                                {
                                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Host does not exist.", e.PrivateMessage.User.Nick));
                                                }
                                                else
                                                {
                                                    this.blackListedHostExploitChecker.Remove(split[2]);

                                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Host successfully removed.", e.PrivateMessage.User.Nick));
                                                }
                                                break;

                                            case "flush":
                                                // TODO : persist this.blackListedHostExploitChecker -- Diabolic 15/03/2015
                                                break;
                                        }
                                    }
                                    #endregion
                                    break;

                                case "abusivenick":
                                    #region handle abusivenick
                                    if (split.Length > 2)
                                    {
                                        switch (split[1])
                                        {
                                            case "add":
                                                if (this.abusiveNickExploitChecker.Contains(split[2]))
                                                {
                                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Word already exists.", e.PrivateMessage.User.Nick));
                                                }
                                                else
                                                {
                                                    this.abusiveNickExploitChecker.Add(split[2]);

                                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Word successfully added.", e.PrivateMessage.User.Nick));
                                                }
                                                break;

                                            case "remove":
                                                if (!this.abusiveNickExploitChecker.Contains(split[2]))
                                                {
                                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Host does not exist.", e.PrivateMessage.User.Nick));
                                                }
                                                else
                                                {
                                                    this.abusiveNickExploitChecker.Remove(split[2]);

                                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Word successfully removed.", e.PrivateMessage.User.Nick));
                                                }
                                                break;

                                            case "flush":
                                                // TODO : persist this.abusiveNickExploitChecker -- Diabolic 15/03/2015
                                                break;
                                        }
                                    }
                                    #endregion
                                    break;

                                case "verbose":
                                    #region handle verbose
                                    if (string.IsNullOrEmpty(split[1]))
                                    {
                                        if (split[1] == "off")
                                        {
                                            this.beVerbose = false;
                                        }
                                        else
                                        {
                                            this.beVerbose = true;
                                        }
                                    }
                                    #endregion
                                    break;

                                case "reload":
                                    #region handle reload
                                    this.abusiveNickExploitChecker.SetAll(GetAbusiveWordList());
                                    this.blackListedHostExploitChecker.SetAll(GetBlackListedHostList());

                                    this.rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :Lists reloaded.", e.PrivateMessage.User.Nick));
                                    #endregion
                                    break;

                                case "ban":
                                    #region handle ban
                                    if (split.Length == 3 && split[1].StartsWith("#"))
                                    {
                                        client.WhoIs
                                        (
                                            split[2],
                                            whois =>
                                            {
                                                if (whois != null && whois.User != null && !string.IsNullOrWhiteSpace(whois.User.Hostname))
                                                {
                                                    this.rawMessageQueue.Enqueue(string.Format("MODE {0} +b *!*@{1}", split[1], whois.User.Hostname));
                                                }
                                            }
                                        );
                                    }
                                    #endregion
                                    break;

                                case "unban":
                                    #region handle unban
                                    if (split.Length == 3 && split[1].StartsWith("#"))
                                    {
                                        client.WhoIs
                                        (
                                            split[2],
                                            whois =>
                                            {
                                                if (whois != null && whois.User != null && !string.IsNullOrWhiteSpace(whois.User.Hostname))
                                                {
                                                    this.rawMessageQueue.Enqueue(string.Format("MODE {0} -b *!*@{1}", split[1], whois.User.Hostname));
                                                }
                                            }
                                        );
                                    }
                                    #endregion
                                    break;

                                case "voice":
                                    #region handle voice
                                    if (split.Length == 3 && split[1].StartsWith("#"))
                                    {
                                        this.rawMessageQueue.Enqueue(string.Format("MODE {0} +v {1}", split[1], split[2]));
                                    }
                                    #endregion
                                    break;

                                case "devoice":
                                    #region handle devoice
                                    if (split.Length == 3 && split[1].StartsWith("#"))
                                    {
                                        this.rawMessageQueue.Enqueue(string.Format("MODE {0} -v {1}", split[1], split[2]));
                                    }
                                    #endregion
                                    break;

                                case "kick":
                                    #region handle kick
                                    if (split.Length >= 3 && split[1].StartsWith("#"))
                                    {
                                        var reason = split.Length > 3 ? string.Join(" ", split.Skip(3)) : Settings.Default.KickReason;
                                        var chan = client.Channels.FirstOrDefault(c => string.Compare(c.Name, split[1], StringComparison.OrdinalIgnoreCase) == 0);

                                        if (chan != null)
                                        {
                                            if (chan.UsersByMode.ContainsKey('o') && chan.UsersByMode['o'].Any(u => string.Compare(u.Nick, client.User.Nick, StringComparison.OrdinalIgnoreCase) == 0))
                                            {
                                                chan.Kick(split[2], reason);
                                            }
                                            else
                                            {
                                                rawMessageQueue.Enqueue(string.Format("PRIVMSG {0} :I am not an op there.", e.PrivateMessage.User.Nick));
                                            }
                                        }
                                    }
                                    #endregion
                                    break;
                            }
                        }
                    }
                }
                catch
                {
                    // TODO : log exception -- Diabolic 15/03/2015
                }
            }
        }

        private void HandleUserJoinedChannel(object sender, ChannelUserEventArgs e)
        {
            var client = sender as IrcClient;

            if (!this.ignoredChannels.Contains(e.Channel.Name.ToLower()))
            {
                var hostnameExploitTypes = this.hostnameExploitChecker.Check(() => e.User.Hostname);
                var nickExploitTypes = this.nickExploitChecker.Check(() => e.User.Nick);

                var exploitTypes = hostnameExploitTypes.Union(nickExploitTypes).Distinct();

                var exploitsString = string.Empty;

                exploitsString = exploitTypes.Aggregate(new StringBuilder(), (sb, et) => sb.AppendFormat("{0}, ", et.ToString())).ToString();
                exploitsString = exploitsString.ToString().TrimEnd(',', ' ');

                if (this.beVerbose || exploitTypes.Any())
                {
                    var untoleratedExploitTypes = GetUntoleratedExploitTypes();

                    if (exploitTypes.Any(untoleratedExploitTypes.Contains))
                    {
                        this.rawMessageQueue.Enqueue
                        (
                            string.Format
                            (
                                "PRIVMSG {0} :KICK Trigger: in {1}, Nick: {2}, Host {3}, Exploits: {4}",
                                Settings.Default.ReportingChannel,
                                e.Channel.Name,
                                e.User.Nick,
                                e.User.Hostname,
                                exploitTypes.Any() ? exploitsString : "None"
                            )
                        );

                        if (e.Channel != null && e.Channel.UsersByMode.ContainsKey('o') && e.Channel.UsersByMode['o'].Any(x => x.Nick == client.User.Nick))
                        {
                            client.SendRawMessage("MODE {0} +ban *!*@{1}", e.Channel.Name, e.User.Hostname);

                            e.Channel.Kick(e.User.Nick, Settings.Default.KickReason);
                        }
                    }
                    else
                    {
                        this.rawMessageQueue.Enqueue
                        (
                            string.Format
                            (
                                "PRIVMSG {0} :Joins {1}, Nick: {2}, Host {3}, Exploits: {4}",
                                Settings.Default.ReportingChannel,
                                e.Channel.Name,
                                e.User.Nick,
                                e.User.Hostname,
                                exploitTypes.Any() ? exploitsString : "None"
                            )
                        );
                    }
                }
            }
        }

        private static IEnumerable<ExploitType> GetUntoleratedExploitTypes()
        {
            var exploitTypes = new List<ExploitType>();

            switch (Settings.Default.ToleranceLevel)
            {
                case 10:
                    exploitTypes.Add(ExploitType.Banlist_Match);
                    break;

                case 7:
                    exploitTypes.Add(ExploitType.Nick_Abuser);
                    break;

                case 5:
                    exploitTypes.Add(ExploitType.OpenProxy);
                    exploitTypes.Add(ExploitType.OpenWingateProxy);
                    exploitTypes.Add(ExploitType.HTTPProxy);
                    exploitTypes.Add(ExploitType.SocksProxy);
                    exploitTypes.Add(ExploitType.ProxyChain);
                    break;

                case 3:
                    exploitTypes.Add(ExploitType.IRCDrone);
                    exploitTypes.Add(ExploitType.Bottler);
                    exploitTypes.Add(ExploitType.AutomaticallyDeterminedBotnet);
                    exploitTypes.Add(ExploitType.Drones_Flooding);
                    exploitTypes.Add(ExploitType.DDOSDrone);
                    exploitTypes.Add(ExploitType.UnknownSpambotOrDrone);
                    break;
            }

            return exploitTypes.Distinct();
        }

        private static IEnumerable<string> GetBlackListedHostList()
        {
            return GetLinesFromFile(Settings.Default.BlackListedHostsPath);
        }

        private static IEnumerable<string> GetAbusiveWordList()
        {
            return GetLinesFromFile(Settings.Default.AbusiveWordsPath);
        }

        private static IEnumerable<string> GetLinesFromFile(string path)
        {
            if (string.IsNullOrWhiteSpace(path))
            {
                throw new InvalidOperationException("path cannot be null or empty");
            }

            if (!File.Exists(path))
            {
                throw new FileNotFoundException(path);
            }

            var lines = new List<string>();

            using (var reader = new StreamReader(path))
            {
                var line = string.Empty;

                while ((line = reader.ReadLine()) != null)
                {
                    if (!string.IsNullOrEmpty(line))
                    {
                        lines.Add(line);
                    }
                }
            }

            return lines.Distinct().ToArray();
        }
    }
}